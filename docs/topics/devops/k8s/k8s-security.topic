<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
  SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic id="k8s-security"
       title="Security"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd">

  <chapter title="4cs of cloud native security" id="4_cs_of_cloud_native_security">
    <p>
      Each layer of the cloud native security model builds on the layers above it. The Code layer benefits from strong base (Cloud,
      Cluster, Container) security layers. You cannot safeguard against poor security standards in the base layers by addressing security at
      the Code level.
    </p>
    <list>
      <li>Cloud
        <list>
          <li>The foundational layer where your cloud infrastructure resides</li>
          <li>Includes cloud provider security controls, IAM policies, network security, and encryption at rest</li>
          <li>Focus on secure configuration of cloud accounts, securing APIs, managing access controls, resource policies, and compliance
            requirements
          </li>
        </list>
      </li>
      <li>Cluster
        <list>
          <li>The container orchestration layer, typically Kubernetes clusters</li>
          <li>Involves securing cluster components like control plane, nodes, and network policies</li>
          <li>Focus on hardening the cluster against unauthorized access and attacks - RBAC, pod security policies, and secure cluster
            configurations
          </li>
        </list>
      </li>
      <li>Container
        <list>
          <li>The application packaging layer where code runs</li>
          <li>Encompasses container image security, runtime security, and vulnerability management (e.g. minimal base images, scanning for
            vulnerabilities, signing images, running as non-root, read-only root filesystems)
          </li>
        </list>
      </li>
      <li>Code
        <list>
          <li>The innermost layer where application code and dependencies live</li>
          <li>Focuses on secure coding practices, dependency management(+SCA), and SAST/DAST</li>
          <li>Includes secure API design, input validation, proper error handling, supply chain security, secrets management, and secure
            CI/CD pipelines
          </li>
        </list>
      </li>
    </list>
  </chapter>


  <chapter title="RBAC" id="rbac">
    <list>
      <li><a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-subjects">Subject</a>
        <list>
          <li>Users are authenticated based on the Common Name (CN) field in a client certificate.</li>
          <li>Group in Kubernetes is a logical way to manage permissions for multiple users at once. Users can belong to one or more
            groups. Groups are specified in the Organization (O) field of the certificate.
          </li>
          <li>ServiceAccount is a special type of Kubernetes account used to provide identity for processes running in Pods. If you don't
            specify a service account when creating a Pod, it will use the <code>default</code> service account in the namespace.
            Every namespace has a default service account, and Kubernetes automatically associates it with Pods in that namespace. The
            <code>default</code> service accounts in each namespace get no permissions by default other than the default API discovery
            permissions that Kubernetes grants to all authenticated principals.
          </li>
        </list>
      </li>
      <li>A Role always sets permissions within a particular namespace</li>
      <li>ClusterRole is a non-namespaced resource. A ClusterRole can be used to grant the same permissions as a Role. Because ClusterRoles
        are cluster-scoped, you can also use them to grant access to cluster-scoped resources (like nodes), non-resource endpoints (like
        /healthz), namespaced resources (like Pods), across all namespaces
      </li>
    </list>

    <code-block lang="yaml" src="$WRS_MODULE$/code/k8s/rbac.yml" collapsible="true" collapsed-title="Basic Example"/>

    <chapter title="Role Binding" id="role_binding">
      <p>
        A role binding grants the permissions defined in a role to a user or set of users. It holds a list of <i>subjects</i> (users,
        groups, or service accounts), and a reference to the role being granted. A <code>RoleBinding</code> grants permissions within a
        specific namespace whereas a <code>ClusterRoleBinding</code> grants that access cluster-wide. If you try to change a binding's
        <code>roleRef</code>, you get a validation error. If you do want to change the <code>roleRef</code> for a binding, you need to
        remove the binding object and create a replacement.
      </p>
      <p>
        <b>A <code>RoleBinding</code> can also reference a <code>ClusterRole</code> to grant the permissions defined in that ClusterRole to
          resources inside the RoleBinding's namespace.</b> This kind of reference lets you define a set of common roles across your
        cluster, then reuse them within multiple namespaces. For instance, even though the following RoleBinding refers to a ClusterRole,
        "dave" (the subject, case-sensitive) will only be able to read Secrets in the "development" namespace, because the RoleBinding's
        namespace (in its metadata) is "development".
      </p>
      <code-block lang="yaml" src="$WRS_MODULE$/code/k8s/rbac-rb-cr.yml" collapsed-title="Example" collapsible="true"/>
      <p>
        To grant permissions across a whole cluster, you can use a <code>ClusterRoleBinding</code>. For example, it can allow any user in
        the group "manager" to read secrets in any namespace. <code>ClusterRoleBinding</code> cannot reference a <code>Role</code> and only
        can reference a <code>ClusterRole</code>.
      </p>
    </chapter>
  </chapter>
</topic>
