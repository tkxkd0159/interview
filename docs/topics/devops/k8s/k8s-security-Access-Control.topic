<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
  SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="Access Control" id="k8s-security-Access-Control" help-id="k8s-Access-Control">

  <show-structure depth="2" for="chapter"/>

  <chapter title="RBAC" id="rbac">
    <list>
      <li><a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-subjects">Subject</a>
        <list>
          <li><code>Users</code> are authenticated based on the Common Name (CN) field in a client certificate.</li>
          <li><code>Group</code> in Kubernetes is a logical way to manage permissions for multiple users at once. Users can belong to one or
            more
            groups. Groups are specified in the Organization (O) field of the certificate.
          </li>
          <li>
            <p>
              <code>ServiceAccount</code> is a special type of Kubernetes account used to provide identity for processes running in Pods. If
              you don't specify a service account when creating a Pod, it will use the <code>default</code> service account in the
              namespace. Every namespace has a default service account, and Kubernetes automatically associates it with Pods in that namespace.
            </p>
            <p>
              The
              <code>default</code> service accounts in each namespace get no permissions by default other than the default API discovery
              permissions that Kubernetes grants to all authenticated principals. However, it only scopes the permissions against Kubernetes
              API. The ability for pods to communicate with each other over thet network is independent of the <code>ServiceAccount</code>.
              Kubernetes allows all pods to communicate with each other by default. If you need to control this, you would use <code>NetworkPolicy</code>
              or third-party sidecar like <code>Istio</code>, <code>Envoy</code>, <code>kube-rbac-proxy</code>.
            </p>
            <list>
              <li><code>kubelet</code> mount a default ServiceAccount credential automatically on <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code>
                of the pod unless you set <code>automountServiceAccountToken: false</code></li>
            </list>
          </li>
        </list>
      </li>
      <li>A <code>Role</code> always sets permissions within a particular namespace</li>
      <li><code>ClusterRole</code> is a non-namespaced resource. A ClusterRole can be used to grant the same permissions as a Role. Because
        ClusterRoles
        are cluster-scoped, you can also use them to grant access to cluster-scoped resources (like nodes), non-resource endpoints (like
        /healthz), namespaced resources (like Pods), across all namespaces
      </li>
    </list>

    <code-block lang="yaml" src="$WRS_MODULE$/code/k8s/rbac.yml" collapsible="true" collapsed-title="Basic Example"/>

    <chapter title="Role Binding" id="role_binding">
      <p>
        A role binding grants the permissions defined in a role to a user or set of users. It holds a list of <i>subjects</i> (users,
        groups, or service accounts), and a reference to the role being granted. A <code>RoleBinding</code> grants permissions within a
        specific namespace whereas a <code>ClusterRoleBinding</code> grants that access cluster-wide. If you try to change a binding's
        <code>roleRef</code>, you get a validation error. If you do want to change the <code>roleRef</code> for a binding, you need to
        remove the binding object and create a replacement.
      </p>
      <p>
        <b>A <code>RoleBinding</code> can also reference a <code>ClusterRole</code> to grant the permissions defined in that ClusterRole to
          resources inside the RoleBinding's namespace.</b> This kind of reference lets you define a set of common roles across your
        cluster, then reuse them within multiple namespaces. For instance, even though the following RoleBinding refers to a ClusterRole,
        "dave" (the subject, case-sensitive) will only be able to read Secrets in the "development" namespace, because the RoleBinding's
        namespace (in its metadata) is "development".
      </p>
      <code-block lang="yaml" src="$WRS_MODULE$/code/k8s/rbac-rb-cr.yml" collapsed-title="Example" collapsible="true"/>
      <p>
        To grant permissions across a whole cluster, you can use a <code>ClusterRoleBinding</code>. For example, it can allow any user in
        the group "manager" to read secrets in any namespace. <code>ClusterRoleBinding</code> cannot reference a <code>Role</code> and only
        can reference a <code>ClusterRole</code>.
      </p>
    </chapter>
  </chapter>

  <chapter title="API" id="api">
    <chapter title="Certificate" id="certificate">
      User must have a certificate issued by the Kubernetes cluster to be able to authenticate and invoke APIs. Kubernetes provides <a
      href="https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers">built-in
      signers</a> that each have a well-known <code>signerName</code>. You can issue a certificate for a user by <a
      href="https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/#normal-user">creating a
      CertificateSigningRequest</a> (CSR) object in the Kubernetes API.
    </chapter>
  </chapter>
</topic>
